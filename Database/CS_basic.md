# Database
## 1. [Index] 
   + ### Index란? : 
      **데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.** 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.
      
      인덱스를 활용하면, 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다. 그러한 이유는 해당 연산을 수행하려면 해당 대상을 조회해야만 작업을 할 수 있기 때문이다.만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야 한다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.      
   + ### Index의 관리 : 
      DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.  
      
      + Insert :새로운 데이터에 대한 인덱스를 추가함  
      + DELETE :삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함  
      + UPDATE :기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함

   + ### Index의 장점과 단점  
      + **장점**
         + 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
         + 전반적인 시스템 부하를 줄일 수 있다.  
         
      + **단점**
         + 인덱스를 관리하기 위해서 DB의 약 10%의 추가적인 공간이 필요하다. 
         + 인덱스를 관리하기 위해 추가적인 작업이 필요하다.  
            
          만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 **인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다**. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다. 앞에서 설명한대로, UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 하였다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.
       

   + ### Index 사용하기 좋은 상황
      + 규모가 큰 테이블
      + Insert,Delete,Update가 빈번하게 일어나지 않는 컬럼  
        
      인덱스를 사용하는 것 만큼 중요한 것이 인덱스의 관리이다. 사용하지 않는다고 체크된 인덱스의 경우 바로 제거를 해주어야 한다.
   + ### Index의 자료구조
      + Hash Table :
         + 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 **빠른 데이터 검색이 필요할 때 유용하다**. 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조이다. 해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원한다.  
         + 하지만 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그러한 이유는 해시가 등호(=) 연산에만 특화되었기 때문이다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

         
      + B+ Tree :
         + B-Tree는 위처럼 하나의 노드에 여러 데이터가 저장 가능한 트리이며, 노드 내의 데이터들은 항상 정렬된 상태인 트리이다. 
         + RedBlack-Tree의 치명적 단점 : '하나의 노드 내의 데이터 개수'이다.
         + RedBlack-Tree는 하나의 노드 내에 무조건 하나의 데이터만을, B-Tree는 하나의 노드 내에 여러 데이터를 저장할 수 있다. ->  **"데이터 탐색 시의 속도 차이"**
         + RedBlack-Tree는 포인터로 연결 / B-Tree는 배열로 저장 따라서 속도가 배열이 훨씬 빠르므로 B-Tree가 훨씬 빠르다.
         + 배열의 치명적 단점 : 배열이라는 자료구조에서 빠른 것은 "탐색"뿐이다. 삽입 및 삭제 시에는 기존 데이터들을 이동하는 시간이 걸려서 평균적으로 O(N)이 걸린다.
         + 그러므로 답은 B-Tree를 사용한다!!!!
   + ### B+ Tree를 쓰는 이유
      1 트리 내 모든 데이터가 항상 정렬된 상태로 유지되기 때문에, 등호(=) 연산뿐만 아니라 부등호(>, <) 연산 처리도 가능하다.
      2 포인터 접근 방식이 적어 매우 많은 데이터가 있어도 속도 이슈가 적다.
      3 데이터 탐색뿐 아니라, 삽입 및 수정 및 삭제에도 항상 O(log N)의 시간 복잡도를 가진다.  
      
   
   
## 2. 정규화
   + ### 정규화란 ?
      + 정규화(Normalization)의 기본 목표는 테이블 간에 **중복된 데이타를 허용하지 않는다는 것이다**. 중복된 데이터를 허용하지 않음으로써 **무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다**.
      + 무결성 :무결성이란 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 **일치하는 정확성을 의미한다**.
      + **무결성의 종류** :
      
         + 널 무결성 :릴레이션의 특정속성 값이 Null이 될 수 없도록 하는 규정
         + 고유 무결성 :릴레이션의 특정 속성에 대해서 각 튜플이 갖는 값들이 서로 달라야 한다는 규정
         + 참조 무결성 :외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다는 규정 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
         + 도메인 무결성 :특정 속성의 값이, 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정
         + 키 무결성 :하나의 테이블에는 적어도 하나의 키가 존재해야 한다는 규정
      + **무결성의 제약조건** :
         + 개체 무결성 : 릴레이션에서 기본키를 구성하는 속성은 Null값이나 중복값을 가질 수 없다.
         + 참조 무결성 : 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다. 

   + ### 정규화 과정 :
      + **제 1정규화** :제1 정규화란 테이블의 컬럼이 원자값(Atomic Value, **하나의 값)을 갖도록 테이블을 분해**하는 것이다. Ex) 취미들 -> 취미로 속성을 바꾼다. 하나의 속성에 대해서 하나의 값만 가지게 테이블을 분해하는 과정이다.
      + **제 2정규화** :제2 정규화란 제1 정규화를 진행한 테이블에 대해 **완전 함수 종속을 만족하도록 테이블을 분해하는 것이다**. 여기서 완전 함수 종속이라는 것은 **기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한**다.  
       ![image](https://user-images.githubusercontent.com/63469069/140735372-e6345237-c808-4619-8214-f06c027f29c3.png)  
       
       위 그림에서 현재 key는 학생번호,강좌이름 2개인데 그중 부분집합 중 하나인 강좌이름이 강의실을 결정할 수 있다. 그러므로 이를 완전함수 종속을 분만족하므로 테이블을 아래와 같이 분해하는 작업을 의미한다.  
       
       ![image](https://user-images.githubusercontent.com/63469069/140735517-d0a6cefc-fb6f-4b9e-9030-ef3bf2c0bb93.png)

      + **제 3정규화** :제3 정규화란 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다. 여기서 이행적 종속이라는 것은 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미한다.
      ![image](https://user-images.githubusercontent.com/63469069/140736073-fd35fa9f-e8ba-4f16-8002-517ec4f35e76.png)  
      
      위 그림에서 기존의 테이블에서 학생 번호는 강좌 이름을 결정하고 있고, 강좌 이름은 수강료를 결정하고 있다. 그렇기 때문에 이를 (학생 번호, 강좌 이름) 테이블과 (강좌 이름, 수강료) 테이블로 분해해야 한다. 분해하는 이유는 만약 501번 학생이 다른강좌로 바꿀 경우에 강좌이름, 수강료 전부바꾸어야 하는 번거로움이 존재하기 때문이다.

      ![image](https://user-images.githubusercontent.com/63469069/140736125-b65d616c-6d1c-46b9-9262-e467ec52ab02.png)
      + **BCNF 정규화** :BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다. 예를 들어 다음과 같은 특강수강 테이블이 존재한다고 하자.  
      
      ![image](https://user-images.githubusercontent.com/63469069/140736709-312d82ac-6c77-4b42-9703-0e6e6ecd1648.png)   
        
        위 그림에서 기본키가 아닌 '교수' 결정자가 존재한다. 그러므로 결정자들이 KEY가 되도록 테이블을 아래와 같이 분해한다.  
        
        ![image](https://user-images.githubusercontent.com/63469069/140736891-aa53a1b5-7083-47c3-811c-99f9db89c9c4.png)  
        
   
## 3. 트랜잭션(이상현상 +)
   + ###트랜잭션 이란?
      + ㅇ
      + ㅇ
   + ㅇ
   + 
## 4. DB의 종류
