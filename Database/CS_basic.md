# Database
# Table Of Contents :

   + [1.Index](#1-index)
   + [2.정규화](#2-정규화)
   + [3.트랜잭션](#3-트랜잭션)
   + [4. RDB vs NOSQL](4-rdbms-vs-nosql)
## 1. [Index]
   + ### Index란? : 
      **데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.** 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.
      
      인덱스를 활용하면, 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다. 그러한 이유는 해당 연산을 수행하려면 해당 대상을 조회해야만 작업을 할 수 있기 때문이다.만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야 한다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.      
   + ### Index의 관리 : 
      DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.  
      
      + Insert :새로운 데이터에 대한 인덱스를 추가함  
      + DELETE :삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함  
      + UPDATE :기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함

   + ### Index의 장점과 단점  
      + **장점**
         + 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
         + 전반적인 시스템 부하를 줄일 수 있다.  
         
      + **단점**
         + 인덱스를 관리하기 위해서 DB의 약 10%의 추가적인 공간이 필요하다. 
         + 인덱스를 관리하기 위해 추가적인 작업이 필요하다.  
            
          만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 **인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다**. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다. 앞에서 설명한대로, UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 하였다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다.
       

   + ### Index 사용하기 좋은 상황
      + 규모가 큰 테이블
      + Insert,Delete,Update가 빈번하게 일어나지 않는 컬럼  
        
      인덱스를 사용하는 것 만큼 중요한 것이 인덱스의 관리이다. 사용하지 않는다고 체크된 인덱스의 경우 바로 제거를 해주어야 한다.
   + ### Index의 자료구조
      + Hash Table :
         + 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 **빠른 데이터 검색이 필요할 때 유용하다**. 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조이다. 해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원한다.  
         + 하지만 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그러한 이유는 해시가 등호(=) 연산에만 특화되었기 때문이다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

         
      + B+ Tree :
         + B-Tree는 위처럼 하나의 노드에 여러 데이터가 저장 가능한 트리이며, 노드 내의 데이터들은 항상 정렬된 상태인 트리이다. 
         + RedBlack-Tree의 치명적 단점 : '하나의 노드 내의 데이터 개수'이다.
         + RedBlack-Tree는 하나의 노드 내에 무조건 하나의 데이터만을, B-Tree는 하나의 노드 내에 여러 데이터를 저장할 수 있다. ->  **"데이터 탐색 시의 속도 차이"**
         + RedBlack-Tree는 포인터로 연결 / B-Tree는 배열로 저장 따라서 속도가 배열이 훨씬 빠르므로 B-Tree가 훨씬 빠르다.
         + 배열의 치명적 단점 : 배열이라는 자료구조에서 빠른 것은 "탐색"뿐이다. 삽입 및 삭제 시에는 기존 데이터들을 이동하는 시간이 걸려서 평균적으로 O(N)이 걸린다.
         + 그러므로 답은 B-Tree를 사용한다!!!!
   + ### B+ Tree를 쓰는 이유
      1 트리 내 모든 데이터가 항상 정렬된 상태로 유지되기 때문에, 등호(=) 연산뿐만 아니라 부등호(>, <) 연산 처리도 가능하다.
      2 포인터 접근 방식이 적어 매우 많은 데이터가 있어도 속도 이슈가 적다.
      3 데이터 탐색뿐 아니라, 삽입 및 수정 및 삭제에도 항상 O(log N)의 시간 복잡도를 가진다.  
      
   
   
## 2. 정규화
   + ### 정규화란 ?
      + 정규화(Normalization)의 기본 목표는 테이블 간에 **중복된 데이타를 허용하지 않는다는 것이다**. 중복된 데이터를 허용하지 않음으로써 **무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다**.
      + 무결성 :무결성이란 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 **일치하는 정확성을 의미한다**.
      + **무결성의 종류** :
      
         + 널 무결성 :릴레이션의 특정속성 값이 Null이 될 수 없도록 하는 규정
         + 고유 무결성 :릴레이션의 특정 속성에 대해서 각 튜플이 갖는 값들이 서로 달라야 한다는 규정
         + 참조 무결성 :외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다는 규정 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
         + 도메인 무결성 :특정 속성의 값이, 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정
         + 키 무결성 :하나의 테이블에는 적어도 하나의 키가 존재해야 한다는 규정
      + **무결성의 제약조건** :
         + 개체 무결성 : 릴레이션에서 기본키를 구성하는 속성은 Null값이나 중복값을 가질 수 없다.
         + 참조 무결성 : 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다. 

   + ### 정규화 과정 :
      + **제 1정규화** :제1 정규화란 테이블의 컬럼이 원자값(Atomic Value, **하나의 값)을 갖도록 테이블을 분해**하는 것이다. Ex) 취미들 -> 취미로 속성을 바꾼다. 하나의 속성에 대해서 하나의 값만 가지게 테이블을 분해하는 과정이다.
      + **제 2정규화** :제2 정규화란 제1 정규화를 진행한 테이블에 대해 **완전 함수 종속을 만족하도록 테이블을 분해하는 것이다**. 여기서 완전 함수 종속이라는 것은 **기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한**다.  
       ![image](https://user-images.githubusercontent.com/63469069/140735372-e6345237-c808-4619-8214-f06c027f29c3.png)  
       
       위 그림에서 현재 key는 학생번호,강좌이름 2개인데 그중 부분집합 중 하나인 강좌이름이 강의실을 결정할 수 있다. 그러므로 이를 완전함수 종속을 분만족하므로 테이블을 아래와 같이 분해하는 작업을 의미한다.  
       
       ![image](https://user-images.githubusercontent.com/63469069/140735517-d0a6cefc-fb6f-4b9e-9030-ef3bf2c0bb93.png)

      + **제 3정규화** :제3 정규화란 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다. 여기서 이행적 종속이라는 것은 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미한다.
      ![image](https://user-images.githubusercontent.com/63469069/140736073-fd35fa9f-e8ba-4f16-8002-517ec4f35e76.png)  
      
      위 그림에서 기존의 테이블에서 학생 번호는 강좌 이름을 결정하고 있고, 강좌 이름은 수강료를 결정하고 있다. 그렇기 때문에 이를 (학생 번호, 강좌 이름) 테이블과 (강좌 이름, 수강료) 테이블로 분해해야 한다. 분해하는 이유는 만약 501번 학생이 다른강좌로 바꿀 경우에 강좌이름, 수강료 전부바꾸어야 하는 번거로움이 존재하기 때문이다.

      ![image](https://user-images.githubusercontent.com/63469069/140736125-b65d616c-6d1c-46b9-9262-e467ec52ab02.png)
      + **BCNF 정규화** :BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다. 예를 들어 다음과 같은 특강수강 테이블이 존재한다고 하자.  
      
      ![image](https://user-images.githubusercontent.com/63469069/140736709-312d82ac-6c77-4b42-9703-0e6e6ecd1648.png)   
        
        위 그림에서 기본키가 아닌 '교수' 결정자가 존재한다. 그러므로 결정자들이 KEY가 되도록 테이블을 아래와 같이 분해한다.  
        
        ![image](https://user-images.githubusercontent.com/63469069/140736891-aa53a1b5-7083-47c3-811c-99f9db89c9c4.png)  
        
   
## 3. 트랜잭션
   + ### 트랜잭션 이란?
      + 트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.
     
   + ### 트랜잭션의 ACID :
      + **Actomicity**(원자성) : 
         + 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.
         + 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.
      + **Consistency**(일관성) :
         + 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
         + 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.
      + **Isolation**(독립성,격리성) :
         + 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
         + 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
      + **Durability**(영속성,지속성) :
         + 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.
   + ### 트랜잭션 연산 및 상태 
   
      + **연산 종류**
         + Commit :Commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.
         + Rollback : Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.
         + Redo / Undo :두 연산의 공통점은 복구를 하는 것이다. 하지만 Redo는 사용자가 했던 작업을 그대로 하지만, Undo는 사용자가 했던 작업을 반대로 진행하여 사용자의 작업을 원상태로 바꾸는 것을 의미.
         
         
## 4. RDBMS vs NOSQL
   + ### RDBMS :
      + RDB(Relational Database)란 관계형 데이터 모델에 기초를 둔 데이터베이스다. 관계형 데이터 모델이란 데이터를 구성하는데 필요한 방법 중 하나로 모든 데이터를 2차원 테이블 형태로 표현해준다.
      + 관계형 데이터베이스(RDMBS)에서는 이러한 관계를 나타내기 위해 외래 키(foreign key)라는 것을 사용합니다. 이러한 테이블간의 관계에서 외래 키를 이용한 테이블 간 Join이 가능하다는 게 RDBMS의 가장 큰 특징입니다.
   + ### NOSQL :
      + NOSQL(Not Only SQL)은 관계형 데이터베이스와 반대되는 방식을 사용하여 데이터간의 관계를 정의하지 않는다. RDBMS에서는 스키마에 맞추어 데이터를 관리하여야 하지만 NOSQL은 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있다.
      + 데이터 테이블은 그냥 하나의 테이블이며 테이블 간의 관계를 정의하지 않아 일반적으로 테이블 간 Join도 불가능합니다. 
      + 데이터가 많이짐 -> Scale-up(RDBMS의 단점) -> 일관성을 조금 포기하되 데이터를 분산하여 저장 Scale-out을 목표로 등장.
   + ### RDBMS / NOSQL 장단점
      + **RDBMS**
      + **장점**
         + RDBMS는 위에서 설명을 하였듯이 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장하고 있습니다. 
         + 또한 관계는 각 데이터를 중복없이 한 번만 저장할 수 있습니다.
      + **단점**
         + 테이블간테이블 간 관계를 맺고 있어 시스템이 커질 경우 JOIN문이 많은 복잡한 쿼리가 만들어질 수 있습니다.
         + 성능 향상을 위해서는 서버의 성능을 향상 시켜야하는 Scale-up만을 지원합니다. 이로 인해 비용이 기하급수적으로 늘어날 수 있습니다.
         + 스키마로 인해 데이터가 유연하지 못합니다. 나중에 스키마가 변경 될 경우 번거롭고 어렵습니다.  
         
      + **NOSQL**
      + **장점**
         + NoSQL에서는 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있습니다. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있습니다.
         + 데이터 분산이 용이하며 성능 향상을 위한 Saclue-up 뿐만이 아닌 Scale-out 또한 가능합니다.
      + **단점**
         + 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경 될 경우 수정을 모든 컬렉션에서 수행을 해야 합니다.
         + 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정가 어려울 수 있습니다.
         
   + ### 언제 적합할까 ?
   
      + RDBMS는 데이터 구조가 명확하며 변경 될 여지가 없으며 명확한 스키마가 중요한 경우 사용하는 것이 좋습니다. 또한 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합합니다. 
      
      + NoSQL은 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장이 될 수 있는 경우에 사용하는 것이 좋습니다. 또한 단점에서도 명확하듯이 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시에는 모든 컬렉션에서 수정을 해야 합니다. 이러한 특징들을 기반으로 Update가 많이 이루어지지 않는 시스템이 좋으며 또한 Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 Database를 Scale-Out를 해야 되는 시스템에 적합합니다.
